# 3.29 5 : 20 - 6 : 00 第一次面试-美团闪购

### 

##### 第一次面，表现很差，基础知识掌握太少，会答的没有做到举一反三，不会的太多，面到最后情绪不稳定，越来越紧张，到最后两个编程题的时候，脑子完全不会思考了。

- 介绍一下当前正在做的项目，负责什么部分，如何实现

- 是否使用过Promise,用过Promise的什么API

- 深拷贝

  - `JSON.parse(JSON.stringify(obj))`
    - 不支持函数
    - 不支持undefined（**支持null**）
    - 不支持循环引用，比如 `a = {name: 'a'}`; `a.self = a`; `a2 = JSON.parse(JSON.stringify(a))`
    - 不支持Date，会变成 ISO8601 格式的字符串
    - 不支持正则表达式
    - 不支持Symbol
  - 手写一个递归深拷贝

- 讲一下js的数据类型分别有哪些，他们是在堆中还是栈中

  - 基本类型：null、undefined、string、number、boolean、symbol
  - 引用类型：object、array、function
  - 基本类型声明后**变量的值**会存储到栈中，函数调用时传递的是变量的引用地址
  - 引用类型声明后会将变量的值存储到堆中，然后将此变量的引用地址存储到栈中，函数调用时传递的是对象的地址

- 有没有用过symbol

  - 创建唯一变量，用于创建一个新的Object属性时使其唯一，就算和别人起的名字重复了也是唯一的，不会重复。

- 什么是原型和原型链

  **原型**

  - 引用类型有一个`__proto__(隐式原型)`属性
  - `函数`都有一个`prototype(原型)`属性
  - 引用类型的`__proto__`属性指向它构造函数的`prototype`

  **原型链**

  当访问一个对象的某个属性时，会先在这个对象本身属性上查找，如果没有找到，则会去它的`__proto__`隐式原型上查找，即它的构造函数的prototype，如果还没有找到就会再在构造函数的prototype的`__proto__`中查找，这样一层一层向上查找就会形成一个链式结构，我们称为原型链。

- history和hash的原理及区别,history为什么需要nginx进行配置，如果不配置为什么刷新会显示404

  - hash 虽然出现在 URL 中，但不会被包括在 HTTP 的请求中，因此，对后端完全没有影响，并且改变 hash 值也导致页面重新加载。
  - history利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法去实现改变url并且不重新加载页面

  - hash模式#后面的数据不会发送给服务器，但是history模式没有#，刷新就是实实在在地去请求服务器，但是服务器中肯定没有相应的资源，因为这是页面的url,所以刷新会出现404，提示页面不存在

- 什么情况下会跨域

  - 域名、端口、协议只要存在一处不同就会产生跨域

- 如何解决跨域

  **jsonp**

  - jsonp的原理就是利用`<script>`标签没有跨域限制，通过`<script>`标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。

    ```js
     <script>
        var script = document.createElement('script');
        script.type = 'text/javascript';
    
        // 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数
        script.src = 'http://www.domain.com:8080/login?user=admin&callback=handleCallback';
        document.head.appendChild(script);
    
        // 回调执行函数
        function handleCallback(res) {
            aconsole.log(JSON.stringify(res))
        }
     </script>
    ```

    

  - 缺点：只能发送get请求

  **nginx**反向代理是如何实现的

  - 反向代理是指 客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的。

  - nginx反向代理配置

    ```shell
    #proxy服务器
    server {
        listen       81;
        server_name  www.domain1.com;
    
        location / {
            proxy_pass   http://www.domain2.com:8080;  #反向代理
            proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
            index  index.html index.htm;
    
            # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
            add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
            add_header Access-Control-Allow-Credentials true;
        }
    }
    ```

    

Vue

- 父子组件传参

  - 给子组件定义一个属性，此属性是一个值或者一个方法，然后子组件通过props接收，子组件通过this.$emit传递回去
  - .sync 语法糖

- 爷孙组件传参

  - `$attrs`和`$listeners` ：需要中间组件

    ```vue
    //爷
    <B :messagec="messagec" :msgc="msgc" v-on:getCData="getCData"></B>
    //父
    <C v-bind="$attrs" v-on="$listeners"></C>
    //子
    <p>接受来自father的值：{{$attrs.messagec}}{{$attrs.msgc}}</p>
    ```

  - `provide` 和 `inject`：不需要中间组件，直接穿透

    ```vue
    // provide/inject是解决组件之间的通信问题的利器，不受层级结构的限制。但也不是随便去滥用，通信代表着耦合。
    // 爷
    export default {
      name: "parent",
      data() {
        return {
           name: "Flying bird's blog"
        }
      },
      provide() {
        return {
          provideData: this.name // 祖先组件提供数据
        }
      }
    }
    // 子/孙
    export default {
      name: "child",
      inject: ["provideData"], // 子孙组件接受数据
      created () {
        console.log(this.provideData) // Flying bird's blog
      }
    }
    ```

    

- 如何封装一个定时器组件，父组件给子组件传一个数值，比如60，倒计时结束后将结束状态返回给父组件

  - 通过computed的get、set实现

- watch 和 computed的区别

  **computed**

  - 支持缓存，是基于响应性依赖来进行缓存的，只有依赖数据发生改变，才会重新进行计算
  - 不支持异步操作，如果数据存在异步操作，无法监听到数据的变化
  - 可以通过对数据的get、set进行处理

  **watch**

  - 不支持缓存，数据变化则会直接触发相应操作
  - watch支持异步操作



编程题

- 将一个接口封装成Promise的形式

  

- 数组扁平化

  ```js
  function flatten(arr) {
      const data = arr.reduce((acc, cur) => {
          return acc.concat(Array.isArray(cur) ? flatten(cur) : cur);
      }, [])
      return [...new Set(data)];
  }
  ```

  