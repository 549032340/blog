# 3.31 6:00-7:10 第三次面试-美团基础部门

## 一面

- css选择器有哪些，优先级如何
  - 标记选择器（如：body,div,p,ul,li）
  - id选择器（如：id="name",id="name_txt"）
  
  - 类选择器（如：id="name",id="name_txt"）
  
  - 后代选择器（如：#head .nav ul li 从父集到子孙集的选择器）
  - 子元素选择器（如：div>p ,带大于号>）
  - 伪类选择器（如：就是链接样式,a元素的伪类，4种不同的状态：link、visited、active、hover。）
  
- css选择器的优先级从最高到最低顺序为
  
  - id选择器（#myid）
  - 类选择器（.myclassname）
  - 标签选择器（div,h1,p）
  - 子选择器（ul < li）
  - 后代选择器（li a）
  - 伪类选择（a:hover,li:nth-child）
  
- css选择器优先级是如何计算的

  - 每个规则对应一个初始"四位数"：0、0、0、0
  - 若是 行内选择符，则加1、0、0、0
  - 若是 ID选择符，则加0、1、0、0
  - 若是 类选择符/伪类选择符，则分别加0、0、1、0
  - 若是 元素选择符，则分别加0、0、0、1
  - 算法：将每条规则中，选择符对应的数相加后得到的”四位数“，从左到右进行比较，大的优先级越高。

- 用div实现一个三角形

  - width、height 设置为0，给border一个宽度之后就会发现border是由四个三角形构成的
  - 隐藏任意三个三角形即可实现一个三角形

- flex的属性都有哪些
  
  - flex-wrap：规定flex容器是单行或者多行
  - justify-content
  - align-items
  - flex-grow：规定项目将相对于其他灵活的项目进行扩展的量，默认值是 0
  - flex-shrink：规定项目将相对于其他灵活的项目进行收缩的量，默认值是 1
  
- 用flex实现一个左侧固定右侧自适应的布局

  ```css
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    body {
      width: 100vw;
      height: 100vh;
    }
    .main {
      width: 100%;
      height: 100%;
      display: flex;
    }
    .nav {
      width: 200px;
      background-color: red;
    }
    .content {
      flex: 1;
      /* flex-grow:1; 设置为 1 它就可以占满水平剩余空间 */
      /*flex-grow 属性决定了父元素在空间分配方向上还有剩余空间时，如何分配这些剩余空间。*/
      background-color: blue;
    }
  </style>
  ```

  

- HTTP Header

  - HTTP Header 分为request headers 和 response headers
  - request headers 里有cookie、Content-Type（请求与实体对应的MIME信息）、Accept（指定客户端能够接收的内容类型）、Authorization（HTTP授权的授权证书，比如token）等
  - response headers 里有Content-Type（返回内容的MIME类型）、Cache-Control（告诉所有的缓存机制是否可以缓存及哪种类型）

- 服务器响应状态码

  | 状态码 | 类别 | 原因短语 |
  | ---- | -------- | ---- |
  | 1xx | Informational（信息性状态码） |接受的请求正在处理|
  | 2xx | Success（成功状态码） |请求正常处理完毕|
  | 3xx | Redirection（重定向） |需要进行附加操作以完成请求|
  | 4xx | Client error（客户端错误） |客户端请求出错，服务器无法处理请求|
  | 5xx | Server Error（服务器错误） |服务器处理请求出错|
  
- 什么是闭包，闭包的优缺点

  - 在函数A中声明函数B,B可以访问A的变量，这就是闭包

  - 优点：闭包中的变量一直存在，所以可以实现防抖节流等功能

  - 缺点：我回答的是闭包会造成内存占用，无法进行垃圾回收，面试官说以前是，现在已经没有这种情况了





## 二面 

- 浏览器缓存机制

  - 缓存策略分为**强缓存**和**协商缓存**
    - 强缓存可以通过设置两种 HTTP Header 实现：`Expires` 和 `Cache-Control` 。强缓存表示在缓存期间不需要请求，`state code` 为 200。
    - 协商缓存可以通过设置两种 HTTP Header 实现：`Last-Modified` 和 `ETag` 。
  - 对于频繁变动的资源，首先需要使用 `Cache-Control: no-cache` 使浏览器每次都请求服务器，然后配合 `ETag` 或者 `Last-Modified` 来验证资源是否有效。这样的做法虽然不能节省请求数量，但是能显著减少响应数据大小。

- 可以从服务端开启不走缓存处理，那么为什么webpack打包的时候还需要带上hash值呢

  - 一般来说，现在都会使用工具来打包代码，那么我们就可以对文件名进行哈希处理，只有当代码修改后才会生成新的文件名。基于此，我们就可以给代码文件设置缓存有效期一年 `Cache-Control: max-age=31536000`，这样只有当 HTML 文件中引入的文件名发生了改变才会去下载最新的代码文件，否则就一直使用缓存。

- 性能优化、webpack优化

  - 首屏加载速度优化：webpack分包、按需引入、cdn加速
  
- 代码层面的优化有哪些

  - 组件的懒加载
  - v-if和v-for不同时使用
  - v-for的key使用唯一值，减少diff运算的比对

- 封装一个好的组件应该考虑哪些东西，比如性能、功能、代码（组件设计的原则）

  - 单一职责原则，功能上不要有耦合
  - 不需要传递太多的参数，如果确实组件复杂，可以将多个参数整合到一个参数之中，类似于options
  - 尽量不要重复代码
  - 不要暴露组件内部实现，组件对于外部来说是封闭的，可以拿饮料售卖机举例，我给你投币，你出饮料，具体是怎么出的饮料，我不知道，也不需要关心
  - 不要直接操作DOM
  - 组件接收参数校验严格一些，比如props的type、require、default都设置好

- 觉得自己封装的一个比较好的组件是什么组件，如何封装的

  - 脑子短路了，没有想起来，说了一个贼简单无聊的，应该回答下面这个组件的实现过程

  - 二次封装过element-ui的Upload组件，添加了大文件切片上传，当文件超过多少时会进行切片，每个切片的大小，都可以自定义，然后切片的过程引入了web-worker，创建一个子程序去进行切片，避免因为文件过大卡在切片的过程，然后每个切片都会根据内容生成hsah值，目的时进一步实现断点续传、秒传等功能。此外还实现了取消上传、获取进度功能，取消上传是使用了axios的abort()方法，获取进度是使用了axios的onUploadProgress()方法，其实axios是没有这两个方法的，abort()其实是给这个接口一个cancelToken，通过对应的cancelToken进行的取消，而ajax的abort()可以直接具体到那个接口，直接就进行取消。然后onUploadProgress()方法也是直接沿用了原生的progress()方法。abort()没直接沿用是因为axios是统一引用的，不能直接找到对应的接口调用来源，所以通过cancelToken来实现的。

- 对于用好ts有什么建议

  